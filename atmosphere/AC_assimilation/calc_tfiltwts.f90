! *****************************COPYRIGHT*******************************
! (C) Crown copyright Met Office. All rights reserved.
! For further details please refer to the file COPYRIGHT.txt
! which you should have received as part of this distribution.
! *****************************COPYRIGHT*******************************
!
!+ Calculate weights for a temporal filtering scheme

MODULE calc_tfiltwts_mod

IMPLICIT NONE

CONTAINS

SUBROUTINE Calc_TFiltWts ( StartSec,      & ! in
                           EndSec,        & ! in
                           TS_len_secs,   & ! in
                           ApexSec,       & ! in
                           Cutoff_period, & ! in
                           SBE_period,    & ! in
                           FilterType,    & ! in
                           Weights_len,   & ! in
                           Weights )        ! out

! Description:
!
!   Calculate weights for a temporal filtering scheme.
!
!   FilterType must be one of:
!
!    '1 - Uniform':  Uniform weights.
!
! '2 - Triangular':  Triangular weights. ApexSec is then the second at which
!                    the triangle's apex is to occur. It does not have to fall
!                    on a timestep.
!
!                    To avoid zero weights at the beginning and end of the
!                    filter span, the `base' of the triangle extends one
!                    timestep either side.
!
!   '3 - LancWin':   Weights as determined by standard Fourier analysis (with
!                    Cutoff_period_hrs the nominal cut-off period in hours) but
!                    with a Lanczos window applied to reduce Gibbs'
!                    oscillations.
!
!     '4 - Dolph':   Dolph filter, as descibed by Lynch (1997), MWR, 124,
!                    655-660. SBE_period_hrs is the stop band edge period in
!                    hours.
!
!   (The theory behind the various filters is explained in appendix B of
!   UMDP31.)
!
!   For each filter type, some of the subroutine arguments will be irrelevant:
!
!     Filter type   Irrelevant arguments
!     -----------   --------------------
!
!     'Uniform   '  ApexSec, Cutoff_period, SBE_period.
!     'Triangular'           Cutoff_period, SBE_period.
!     'LancWin   '  ApexSec,                SBE_period.
!     'Dolph     '  ApexSec, Cutoff_period.
!
! Code Owner: See Unified Model Code Owners HTML page
! This file belongs in section: AC Assimilation
!
! Code Description:
!   Language: Fortran 90.
!   This code is written to UMDP3 version 8.1 programming standards.
!
! Declarations:

USE conversions_mod, ONLY: pi
USE yomhook, ONLY: lhook, dr_hook
USE parkind1, ONLY: jprb, jpim

  USE ereport_mod, ONLY : ereport
  IMPLICIT NONE


! DEPENDS ON: chebpoly

! Subroutine arguments:

INTEGER, INTENT(IN)  :: StartSec      ! Start second of filter
INTEGER, INTENT(IN)  :: EndSec        ! End   second of filter
INTEGER, INTENT(IN)  :: TS_len_secs   ! Timestep length in seconds
INTEGER, INTENT(IN)  :: ApexSec       ! Max weight second for triangular filter
REAL,    INTENT(IN)  :: Cutoff_period ! Cut-off period in hours
REAL,    INTENT(IN)  :: SBE_period    ! Stop band edge period in hours
INTEGER, INTENT(IN)  :: FilterType
INTEGER, INTENT(IN)  :: Weights_len
REAL,    INTENT(OUT) :: Weights(Weights_len) ! Filter weights

! Local constants:

CHARACTER(LEN=*), PARAMETER :: RoutineName = 'Calc_TFiltWts'

REAL, PARAMETER :: MinNonZeroWeight = 1.0E-12 ! Minimum abs value for non-zero
                                              ! weights, to remove tiny weights
                                              ! generated by rounding error

! Local variables:

INTEGER :: m
INTEGER :: n
INTEGER :: j
INTEGER :: index
INTEGER :: ICode
INTEGER :: NumWeights
INTEGER :: WeightNum
INTEGER :: Sec          ! Second
INTEGER :: BaseStartSec ! Start second of triangle base
INTEGER :: BaseEndSec   ! End   second of triangle base

REAL :: X
REAL :: TmpSum
REAL :: ThetaC   ! Digital cut-off frequency
REAL :: ThetaS   ! Digital SBE     frequency
REAL :: ThetaI
REAL :: ThetaJ
REAL :: X_zero   ! Main lobe width
REAL :: r        ! Ripple ratio
REAL :: ChebPoly ! Chebyshev polynomial

CHARACTER(LEN=320) :: CMessage

INTEGER(KIND=jpim), PARAMETER :: zhook_in  = 0
INTEGER(KIND=jpim), PARAMETER :: zhook_out = 1
REAL(KIND=jprb)               :: zhook_handle

!- End of header ---------------------------------------------------------------

!-------------------------------------------------------------------------------
! [1]: Check inputs and set up some variables.
!-------------------------------------------------------------------------------

IF (lhook) CALL dr_hook('CALC_TFILTWTS',zhook_in,zhook_handle)

IF (FilterType /= 1 .AND. &
    FilterType /= 2 .AND. &
    FilterType /= 3 .AND. &
    FilterType /= 4) THEN
  ICode = 1
  CMessage(1 :30)  = 'Invalid filter type '
  CMessage(31:160) =  &
         'Valid types: 1 - Uniform, 2 - Triangular, 3 - LancWin, 4 - Dolph'
  CALL EReport (RoutineName, ICode, CMessage)
END IF

IF (EndSec < StartSec) THEN
  ICode = 1
  WRITE (CMessage,'(A,I6,A,I6)') &
    'End second ', EndSec, ' before start second ', StartSec
  CALL EReport (RoutineName, ICode, CMessage)
END IF

IF (MOD(StartSec, TS_len_secs) /= 0 .OR.   &
    MOD(EndSec,   TS_len_secs) /= 0) THEN
  ICode = 1
  CMessage(1:80) = 'Filter must start and end on a timestep.'
  WRITE (CMessage(81 :160),'(A,I6)') 'StartSec:    ', StartSec
  WRITE (CMessage(161:240),'(A,I6)') 'EndSec:      ', EndSec
  WRITE (CMessage(241:320),'(A,I6)') 'TS_len_secs: ', TS_len_secs
  CALL EReport (RoutineName, ICode, CMessage)
END IF

NumWeights = (EndSec - StartSec)/TS_len_secs + 1

IF (Weights_len < NumWeights) THEN
  ICode = 1
  WRITE (CMessage,'(A,I4,A,I4)')                      &
    'Length of Weights array  (', Weights_len,        &
    ') is too small. Should be at least ', NumWeights
  CALL EReport (RoutineName, ICode, CMessage)
END IF

IF (NumWeights == 1) THEN
  Weights(:) = 0.0
  Weights(1) = 1.0
  IF (lhook) CALL dr_hook('CALC_TFILTWTS',zhook_out,zhook_handle)
  RETURN
END IF

IF (MOD(NumWeights, 2) /= 1) THEN
  ICode = 1
  CMessage(1:80) = 'Filter must be centred on a timestep.'
  WRITE (CMessage(81 :160),'(A,I6)') 'StartSec:    ', StartSec
  WRITE (CMessage(161:240),'(A,I6)') 'EndSec:      ', EndSec
  WRITE (CMessage(241:320),'(A,I6)') 'TS_len_secs: ', TS_len_secs
  CALL EReport (RoutineName, ICode, CMessage)
END IF

IF (FilterType  ==  2) THEN
  BaseStartSec = StartSec - TS_len_secs
  BaseEndSec   = EndSec   + TS_len_secs
  IF (ApexSec < StartSec .OR. &
      ApexSec > EndSec) THEN
    ICode = 1
    CMessage(1:80) = 'Invalid apex second.'
    WRITE (CMessage(81 :160),'(A,I6)') 'StartSec: ', StartSec
    WRITE (CMessage(161:240),'(A,I6)') 'EndSec:   ', EndSec
    WRITE (CMessage(241:320),'(A,I6)') 'ApexSec:  ', ApexSec
    CALL EReport (RoutineName, ICode, CMessage)
  END IF
END IF

IF (FilterType == 3) THEN

  ! Digital cut-off frequency:
  ThetaC = 2.0 * PI * REAL(TS_len_secs) &
         / (Cutoff_period * 3600.0)

  IF (ThetaC > PI) THEN
    ICode    = 1
    CMessage = 'Cut-off period too small.'
    CALL EReport (RoutineName, ICode, CMessage)
  END IF

  m = (NumWeights - 1)/2

END IF

IF (FilterType == 4) THEN

  ! Digital stop band edge frequency:
  ThetaS = 2.0 * PI * REAL(TS_len_secs) &
         / (SBE_period * 3600.0)

  IF (ThetaS > PI) THEN
    ICode    = 1
    CMessage = 'Stop band edge period too small.'
    CALL EReport (RoutineName, ICode, CMessage)
  END IF

  ! Main lobe width:
  X_zero = 1.0 / ( COS(ThetaS/2.0) )

  ! Ripple ratio:
  r = 1.0 / ChebPoly(X_zero, NumWeights-1)

  m = (NumWeights - 1)/2
  n = NumWeights

END IF

!-------------------------------------------------------------------------------
! [2]: Calculate un-normalised filter weights.
!-------------------------------------------------------------------------------

Weights(:) = 0.0

!-------------------------------------------------------------------------------
! [2.1]: Uniform filter.
!-------------------------------------------------------------------------------

IF (FilterType == 1) Weights(:) = 1.0

!-------------------------------------------------------------------------------
! [2.2]: Triangular filter.
!-------------------------------------------------------------------------------

IF (FilterType == 2) THEN
  DO WeightNum = 1, NumWeights

    Sec = StartSec + (WeightNum - 1) * TS_len_secs

    IF (Sec <= ApexSec) THEN
      Weights(WeightNum) = REAL(Sec     - BaseStartSec) &
                         / REAL(ApexSec - BaseStartSec)
    ELSE
      Weights(WeightNum) = REAL(BaseEndSec - Sec)       &
                         / REAL(BaseEndSec - ApexSec)
    END IF

  END DO
END IF

!-------------------------------------------------------------------------------
! [2.3]: Lanczos-windowed filter.
!-------------------------------------------------------------------------------

IF (FilterType == 3) THEN
  DO WeightNum = 1, NumWeights

    Index = WeightNum - (NumWeights + 1) / 2

    IF (Index /= 0) THEN
      ! Weight from standard Fourier analysis:
      Weights(WeightNum) = SIN(REAL(Index) * ThetaC) &
                         /    (REAL(Index) * PI)

      ! Lanczos window:
      Weights(WeightNum) = Weights(WeightNum)          &
                         * SIN(Index * PI / REAL(m+1)) &
                         /    (Index * PI / REAL(m+1))
    ELSE
      Weights(WeightNum) = ThetaC / PI
    END IF

  END DO
END IF

!-------------------------------------------------------------------------------
! [2.4]: Dolph filter.
!-------------------------------------------------------------------------------

IF (FilterType == 4) THEN
  DO WeightNum = 1, NumWeights

    Index  = WeightNum - (NumWeights + 1)/2

    ThetaI = 2.0 * PI * Index / REAL(n)

    TmpSum = 0.0

    DO j = 1, m
      ThetaJ = 2.0 * PI * j / REAL(n)
      X      = X_zero * COS(ThetaJ / 2.0)
      TmpSum = TmpSum + ChebPoly(X, 2*m) * COS(j * ThetaI)
    END DO

    Weights(WeightNum) = (2.0 * r * TmpSum + 1.0) / REAL(n)

  END DO
END IF

!-------------------------------------------------------------------------------
! [3]: Normalise weights, and remove tiny non-zero weights generated by
!      rounding error.
!-------------------------------------------------------------------------------

Weights(:) = Weights(:) / SUM(Weights)

DO WeightNum = 1, NumWeights
  IF (ABS(Weights(WeightNum)) < MinNonZeroWeight) Weights(WeightNum) = 0.0
END DO

IF (lhook) CALL dr_hook('CALC_TFILTWTS',zhook_out,zhook_handle)
RETURN

END SUBROUTINE Calc_TFiltWts
END MODULE calc_tfiltwts_mod
